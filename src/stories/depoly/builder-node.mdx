import { Meta } from '@storybook/blocks';

<Meta title="部署/builder 前台部署" id="builder-to-1panel" />

## 前言

本文以1Panel web管理面板为例，你也可以是宝塔或者其他面板，能够创建NODE环境即可。

## 打包应用并上传到云服务器

git clone 或者下载web builder：[https://github.com/biaogebusy/web-builder](https://github.com/biaogebusy/web-builder) 到本地，进入目录后：

- npm install 安装依赖包
- 检查web builder的环境变量修改并确认apiUrl是否为你的前台域名：`src/environments/environment.prod.ts`

```ts
import { IEnvironment } from '../app/core/interface/IEnvironment';

export const environment: IEnvironment = {
  apiUrl: 'https://base.builder.design',
  production: true,
  port: 4201,
  cache: true,
  multiLang: true,
  langs: [
    {
      label: '中文',
      langCode: 'zh-hans',
      prefix: '/',
      default: true,
    },
    {
      label: 'EN',
      langCode: 'en',
      prefix: '/en',
    },
  ],
};
```

在项目执行打包命令：`npm run build`最终你的包应该包含：

```
dist
 - browser
 - server
```

把dist目录和package.json一起打包压缩上传到服务器

> package.json 用于1panel中node的启动命令。

解压到该文件夹：
![da21b2ef2a557e768879cae2409bfb51.png](https://picx.zhimg.com/v2-3847bb2e8e2d80d0575fdd9aeca93bf3_r.jpg)
![9d3958ebe625206e511edd5ecfdc0963.png](https://picx.zhimg.com/v2-378c9ff5c05cea83d7a36344c9f37c79_r.jpg)

最终你的路径应该是这样：

- xhb 为你创建的应用目录
- dist 为angular包文件夹

## 创建应用的node运行环境

![d5d99fd360b862652f2057de7e4b2c1d.png](https://pic2.zhimg.com/v2-5c98abe1e20c633c1d513a86e05940db_r.jpg)

首先你先确定好你的node的端口，在server.ts中见代码：

```js
function run(): void {
  const port = environment.port || process.env['PORT'] || 4000;

  // Start up the Node server
  const server = app();
  server.listen(port, () => {
    console.log(`Node Express server listening on http://localhost:${port}`);
  });
}
```

> 因为我的服务器可能有多个node的应用，所以端口自定义在环境变量中

![5cbebdd826a2e237d7e40379ca89e808.png](https://pic4.zhimg.com/v2-bf985b2156067bfded4c0e032ab94cad_r.jpg)

- node 的版本v18以上，这里是v22
- xhb这个目录就是应用的目录，包含dist文件夹和package.json启动命令
- 启动命令就是来自package.json的script，选择启动node的命令
- 端口要对应你应用的端口

创建好之后，可以查看下日志，看看有没有报错
![8958029c53346b26bf6dae4a8d2f5817.png](https://pic1.zhimg.com/v2-b3566a21a533878de70d95497a8d39da_r.jpg)
![b949c26804ed019e18261ca445cca7f2.png](https://pic2.zhimg.com/v2-665e4cf5e86b112117d525eea7cfcd27_r.jpg)
看到命令已经正确执行，说明已经运行起来，如果是空的，可能文件夹接口或者端口错误，会有相关的报错信息。

## 添加web反向代理，绑定域名

node应用跑起来只是内部服务器端口可访问，外部网络是无法访问的，需要添加一个web服务，当访客访问域名的时候转发请求给对应端口的node应用。
![b2e87628a37a3ad3e9bf9a19d27a73fb.png](https://pic1.zhimg.com/v2-1392b51b2f048b2bbe512a9da870346e_r.jpg)

- 填上绑定的域名
- 代理地址填写node的地址：127.0.0.1:4209 （如果你没有改过这个端口都是4200）

> 127.0.0.1是本机地址，加上node的端口即可

## 配置网站

新建好网站之后，还需要配置一些事项：

- 开启https，根据你的应用所需要的后台是否需要https，1panel可申请免费安全证书
- 反向代理配置，如果你的应用不是静态的，跟后台通信，需要把一些api转发给后台

![afd65bff5917a29427d777dce12d9043.png](https://picx.zhimg.com/v2-d4570f3cc511e35e27bac27738353f0f_r.jpg)
![413aff235e811e63187b279be6507441.png](https://picx.zhimg.com/v2-91d1977ffd2ef887ade4d67d4f6f4019_r.jpg)
点击【编辑源文】

![39425431e55179d56e3be3ffd6394b52.png](https://pic3.zhimg.com/v2-5471b71f884fc8c3ec1b67fefd4b8c8e_1440w.jpg)
需要修改`location ^~ /`为`location /` 最终这段的nginx配置在我的应用场景里是这样：

```
location / {
    proxy_pass http://127.0.0.1:4209;
    proxy_set_header Host $host:$server_port;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header REMOTE-HOST $remote_addr;
    proxy_connect_timeout 30s;
    proxy_read_timeout 86400s;
    proxy_send_timeout 30s;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
}
```

如果你的应用是静态的此时访问域名应该可以正常访问了，但是依赖后台api，还需要添加nginx配置：
当访问以这些开头的url时转发给后台，完整结构如下：

```nginx
location ~* ^/(api|en/api|user|admin|manage|system|print|export|sites/([^/]+)/files) {
    proxy_pass http://127.0.0.1:8080;
    proxy_redirect off;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Host $server_name;
    proxy_set_header X-Forwarded-Proto https;
    proxy_set_header X-Forwarded-Port 443;
    proxy_read_timeout 240;
    # proxy_cache xinshi;
    # 要求nginx刷新内容时使用条件请求
    proxy_cache_revalidate on;
    # 访问几次才被缓存，可以确保最常访问的添加到项目中
    proxy_cache_min_uses 1;
    # 有效时间
    # 当后端故障时，提供缓存文件
    proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
    proxy_cache_background_update on;
    # 多个客户端请求缓存是miss,则仅允许第一个去去最新的数据，等缓存更新时，再去提取最新的缓存文件，可以防止未命中的直接发送后台
    proxy_cache_lock on;
    proxy_cache_methods GET HEAD;
    # 不缓存私有数据，url带有no_cache的也忽略
    proxy_cache_bypass $http_x_boost_fetch $arg_nocache $arg_preview $arg_no_cache $cookie_nocache;
    # nginx 当包含Expires没过期或者cache-control 带有private,no-cache,no-store, set-Cookies默认不会缓存响应
    # 检测缓存
    add_header X-Proxy-Cache $upstream_cache_status;
    proxy_buffering on;
    add_header Strict-Transport-Security "max-age=31536000";
    proxy_set_header Host $host;
    if ( $uri ~* "\.(gif|png|jpg|css|js|woff|woff2)$" ) {
        expires 1m;
    }
    proxy_ignore_headers Set-Cookie Cache-Control expires;
    #proxy_cache proxy_cache_panel;
    proxy_cache off; // 测试环境禁用了缓存，到生产可开启
    proxy_cache_key $host$uri$is_args$args;
    proxy_cache_valid 200 304 301 302 10m;
}

location / {
    proxy_pass http://127.0.0.1:4209;
    proxy_set_header Host $host:$server_port;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header REMOTE-HOST $remote_addr;
    proxy_connect_timeout 30s;
    proxy_read_timeout 86400s;
    proxy_send_timeout 30s;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
}
```

配置好之后最好如果访问域名页面没有正常打开，试着重启下node容器：
![0fe2c9204e06139029aab02059f5519e.png](https://pic4.zhimg.com/v2-db8ad78ddfb7fa5273afcd73253d1193_r.jpg)

> Tips: 遇到问题，多看应用日志。
